# Padding Oracle Attacks

## Definitions
* oracle
  * `a system that will perform given cryptographic operations on behalf of the user`
  
* padding oracle
  * `a specific kind of oracle that will take encrypted data from the user, attempt to decrypt it privately, then reveal whether or not the padding is correct (perhaps by executing some code)`
  * `in essence, it decrypts ARBITRARY data`
  
## Block Ciphers
* operates on data in fixed-size blocks
* AES: 128-bit size BLOCKS (keys may be 128, 192, or 256 bits)
* encrypts the first block, then moves to the second, then so on and so forth

### Two Questions with Block Ciphers
* What if the length of the data isn't a multiple of the block size?
* What happens if more than one block is identical, and therefore encrypts identically?

### Padding
* Hashing algorithm padding: `\x80\x00\x00\x00 ... (length)`
* **NOT** how block ciphers pad

#### PKCS(7)
* Padding used by block ciphers is called **PKCS7**
* Value to pad with is the number of bytes of padding required.
* e.g., ABC with block size 8 has padding `\x05\x05\x05\x05\x05`. Final result would look like `ABC\x05\x05\x05\x05\x05`.
* If the data is exactly a multiple of the block size, a new block is filled with just padding (`\x08` * 8 for a 8 byte block size, `\x10` * 16 for a 16 byte - 128 bit - block size)

### Cipher-block Chaining (CBC)
```
Let P = plaintext, P(n) = the plaintext of block n
Let C = ciphertext, C(n) = the ciphertext of block n
Let N = number of blocks, C and P have same number of blocks
Let IV = the initialization vector
Let E() = single block encryption algorithm, with some secret key
Let D() = corresponding decryption algorithm
```

We can define the encrypted cipher text as:

```
C(1) = E( XOR( P(1), IV ))
C(n) = E( XOR( P(n), C(n-1) ), 1 < n < N
```

Decryption is then just (have to reverse the order of the functions - decrypt, then XOR):

```
P(1) = XOR( D(C(1)), IV )
P(n) = XOR( D(C(n)), C(n-1) ), 1 < n < N
```

* Decryption is an operation between a ciphertext block (we control) and a plaintext block (we are interested in).
* Once all blocks are decrypted, the padding on the last block is validated.

## The Attack

Break the ciphertext (that we want to crack) into individual blocks
  * Plan: Decrypt each of the blocks separately (best to go from last to first, i.e. from C(N) to C(1))

Generate own block of ciphertext - usually starts with all zeroes. Doesn't matter what it decrypts to. Denote this block as `C'`, and let `C'[k] = kth BYTE of C'`

Create the string `C' || C(n)`, where `||` means concatenation. Send this string to the oracle for decryption.

We get the following:
```
Let P' = the plaintext generated by decrypting our string (C' || C(n))
Let P'(n) = the nth block of P'
Let P'(n)[k] = the kth BYTE of the nth plaintext block
Let K = the number of bytes in each block
```

```
P'(1) = XOR( D(C'), IV)
P'(2) = XOR( D(C(N)), C')
```

```
Since C(N) = E( P(N), C(N-1) ), we have
P'(2) = XOR( P(N), C(N-1), C')
```

Now we need to find P'(2), calculated by the server and never sent to us.

We send `C' || C(N)` to the oracle with every possible value of `C'[-1]`, until we find a value that doesn't generate a padding error. Then we'll know that `P'(2)[-1]` is `\x01`.

We can then recover `P(N)[-1]`, by computing:

```
P(N)[-1] = XOR( 1, C(N-1)[-1]), C'[-1] )
```

From 

```
P'(2) = XOR( P(N), C(N-1), C')

we get

C'[k] = XOR( P'(2)[k], P(N)[k], C(N-1)[k] )
```

## Reversing CBC Encryption

* https://www.usenix.org/legacy/events/woot10/tech/full_papers/Rizzo.pdf

# Other Resources and Links

* picocTF 2013, Broken CBC
* [SkullSecurity blog](https://blog.skullsecurity.org/2013/padding-oracle-attacks-in-depth)
